diff --git a/block/keyslot-manager.c b/block/keyslot-manager.c
index 1ce66f66af20..f00708b9e43a 100644
--- a/block/keyslot-manager.c
+++ b/block/keyslot-manager.c
@@ -34,52 +34,6 @@
 #include <linux/blkdev.h>
 #include <linux/overflow.h>
 
-struct keyslot {
-	atomic_t slot_refs;
-	struct list_head idle_slot_node;
-	struct hlist_node hash_node;
-	struct blk_crypto_key key;
-};
-
-struct keyslot_manager {
-	unsigned int num_slots;
-	struct keyslot_mgmt_ll_ops ksm_ll_ops;
-	unsigned int features;
-	unsigned int crypto_mode_supported[BLK_ENCRYPTION_MODE_MAX];
-	unsigned int max_dun_bytes_supported;
-	void *ll_priv_data;
-
-#ifdef CONFIG_PM
-	/* Device for runtime power management (NULL if none) */
-	struct device *dev;
-#endif
-
-	/* Protects programming and evicting keys from the device */
-	struct rw_semaphore lock;
-	/*
-	 * Above rw_semaphore maybe nested when used a dm stack layer
-	 * which is with inline encryption
-	 */
-	unsigned int lock_flags;
-
-	/* List of idle slots, with least recently used slot at front */
-	wait_queue_head_t idle_slots_wait_queue;
-	struct list_head idle_slots;
-	spinlock_t idle_slots_lock;
-
-	/*
-	 * Hash table which maps key hashes to keyslots, so that we can find a
-	 * key's keyslot in O(1) time rather than O(num_slots).  Protected by
-	 * 'lock'.  A cryptographic hash function is used so that timing attacks
-	 * can't leak information about the raw keys.
-	 */
-	struct hlist_head *slot_hashtable;
-	unsigned int slot_hashtable_size;
-
-	/* Per-keyslot data */
-	struct keyslot slots[];
-};
-
 static inline bool keyslot_manager_is_passthrough(struct keyslot_manager *ksm)
 {
 	return ksm->num_slots == 0;
@@ -670,19 +624,3 @@ int keyslot_manager_derive_raw_secret(struct keyslot_manager *ksm,
 	return err;
 }
 EXPORT_SYMBOL_GPL(keyslot_manager_derive_raw_secret);
-
-/**
- * ksm_lock() - set one-depth nesting of lock class
- * @flags: now, it's only support one depth
- *
- * Some scenarios ksm->lock will be nest such as DM stack layer,
- * although DM's is different with lower device driver's ksm->lock,
- * lockdep recognizes them as a same one, then will trigger deadlock
- * detection, set another lock sub-class could avoid it.
- *
- */
-inline void ksm_flock(struct keyslot_manager *ksm, unsigned int flags)
-{
-	ksm->lock_flags = flags;
-}
-EXPORT_SYMBOL_GPL(ksm_flock);
diff --git a/include/linux/keyslot-manager.h b/include/linux/keyslot-manager.h
index e247be8a5d43..b3476c0b326a 100644
--- a/include/linux/keyslot-manager.h
+++ b/include/linux/keyslot-manager.h
@@ -98,7 +98,67 @@ int keyslot_manager_derive_raw_secret(struct keyslot_manager *ksm,
 				      unsigned int wrapped_key_size,
 				      u8 *secret, unsigned int secret_size);
 
-inline void ksm_flock(struct keyslot_manager *ksm, unsigned int flags);
+struct keyslot {
+	atomic_t slot_refs;
+	struct list_head idle_slot_node;
+	struct hlist_node hash_node;
+	struct blk_crypto_key key;
+};
+
+struct keyslot_manager {
+	unsigned int num_slots;
+	struct keyslot_mgmt_ll_ops ksm_ll_ops;
+	unsigned int features;
+	unsigned int crypto_mode_supported[BLK_ENCRYPTION_MODE_MAX];
+	unsigned int max_dun_bytes_supported;
+	void *ll_priv_data;
+
+#ifdef CONFIG_PM
+	/* Device for runtime power management (NULL if none) */
+	struct device *dev;
+#endif
+
+	/* Protects programming and evicting keys from the device */
+	struct rw_semaphore lock;
+	/*
+	 * Above rw_semaphore maybe nested when used a dm stack layer
+	 * which is with inline encryption
+	 */
+	unsigned int lock_flags;
+
+	/* List of idle slots, with least recently used slot at front */
+	wait_queue_head_t idle_slots_wait_queue;
+	struct list_head idle_slots;
+	spinlock_t idle_slots_lock;
+
+	/*
+	 * Hash table which maps key hashes to keyslots, so that we can find a
+	 * key's keyslot in O(1) time rather than O(num_slots).  Protected by
+	 * 'lock'.  A cryptographic hash function is used so that timing attacks
+	 * can't leak information about the raw keys.
+	 */
+	struct hlist_head *slot_hashtable;
+	unsigned int slot_hashtable_size;
+
+	/* Per-keyslot data */
+	struct keyslot slots[];
+};
+
+/**
+ * ksm_lock() - set one-depth nesting of lock class
+ * @flags: now, it's only support one depth
+ *
+ * Some scenarios ksm->lock will be nest such as DM stack layer,
+ * although DM's is different with lower device driver's ksm->lock,
+ * lockdep recognizes them as a same one, then will trigger deadlock
+ * detection, set another lock sub-class could avoid it.
+ *
+ */
+inline void ksm_flock(struct keyslot_manager *ksm, unsigned int flags)
+{
+	ksm->lock_flags = flags;
+}
+EXPORT_SYMBOL_GPL(ksm_flock);
 
 #endif /* CONFIG_BLK_INLINE_ENCRYPTION */
 
